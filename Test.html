import openpyxl
import random
import math
from datetime import datetime, timedelta
from collections import defaultdict

# === Load Excel Workbook ===
wb = openpyxl.load_workbook("Outlook_Calendars.xlsx")
appointments = []
technicians = []

# === Load Technicians ===

# === Add or Reset Technicians Sheet ===
if "Technicians" in wb.sheetnames:
    ws_tech = wb["Technicians"]
    wb.remove(ws_tech)
ws_tech = wb.create_sheet("Technicians")

# Header row
ws_tech.append(["Technician", "Available Start", "Available End", "Max Appointments"])

# Sample technician data
sample_techs = [
    ("Alice", "08:00", "16:00", 5),
    ("Bob", "09:00", "17:00", 4),
    ("Charlie", "07:30", "15:30", 6),
    ("Dana", "10:00", "18:00", 3),
    ("Jim", "08:00", "16:00", 5),
    ("Berry", "09:00", "17:00", 4),
    ("Chie", "07:30", "15:30", 6),
    ("Dads", "10:00", "18:00", 3),
]

for tech in sample_techs:
    ws_tech.append(tech)

ws_tech = wb["Technicians"]
for row in ws_tech.iter_rows(min_row=2, values_only=True):
    technicians.append({
        "name": row[0],
        "start": datetime.strptime(row[1], "%H:%M").time(),
        "end": datetime.strptime(row[2], "%H:%M").time(),
        "max": row[3],
    })

# === Load Appointments from First Mailbox Sheet ===
mailbox_sheet = [ws for ws in wb.sheetnames if ws not in ["Technicians", "Optimized Schedule"]][0]
ws_appt = wb[mailbox_sheet]
for row in ws_appt.iter_rows(min_row=2, values_only=True):
    try:
        start_time = row[1]
        end_time = row[2]
        appointments.append({
            "subject": row[0],
            "start": start_time,
            "end": end_time,
            "duration": (end_time - start_time).total_seconds() / 60,
            "location": row[3],
        })
    except Exception:
        continue

# === Simulated Annealing ===
def cost(schedule):
    penalty = 0
    tech_counts = {t["name"]: 0 for t in technicians}

    for i, appt in enumerate(appointments):
        tech = schedule[i]
        tech_info = next(t for t in technicians if t["name"] == tech)
        tech_counts[tech] += 1

        if tech_counts[tech] > tech_info["max"]:
            penalty += 100  # Overbooked

        if not (tech_info["start"] <= appt["start"].time() <= tech_info["end"]):
            penalty += 50  # Outside working hours

    return penalty

# === Initialize Random Assignment ===
current = [random.choice(technicians)["name"] for _ in appointments]
best = list(current)
best_cost = cost(best)

T = 1000.0
T_min = 1.0
alpha = 0.95

while T > T_min:
    i = random.randint(0, len(appointments)-1)
    new = list(current)
    new[i] = random.choice(technicians)["name"]

    curr_cost = cost(current)
    new_cost = cost(new)

    if new_cost < curr_cost or math.exp((curr_cost - new_cost) / T) > random.random():
        current = new
        if new_cost < best_cost:
            best = new
            best_cost = new_cost

    T *= alpha

from openpyxl.utils import get_column_letter
from collections import defaultdict

# === Build schedule map by technician ===
schedule_map = defaultdict(list)  # {tech_name: [(start_time, end_time, subject)]}

for i, appt in enumerate(appointments):
    schedule_map[best[i]].append((appt["start"], appt["end"], appt["subject"]))

# === Create the "Schedule View" sheet ===
if "Schedule View" in wb.sheetnames:
    del wb["Schedule View"]
ws_sched = wb.create_sheet("Schedule View")

# Time slots to visualize (30-min increments from earliest to latest appointment)
all_times = [appt["start"] for appt in appointments] + [appt["end"] for appt in appointments]
min_time = min(all_times).replace(minute=0)
max_time = max(all_times)
time_slots = []
cur = min_time
while cur <= max_time:
    time_slots.append(cur)
    cur += timedelta(minutes=30)

# Technician columns
tech_names = [t["name"] for t in technicians]
ws_sched.append(["Time"] + tech_names)

# Create a lookup for start time row numbers
time_row_map = {slot.strftime("%H:%M"): idx + 2 for idx, slot in enumerate(time_slots)}

# Fill time labels in column A
for idx, slot in enumerate(time_slots):
    ws_sched.cell(row=idx + 2, column=1).value = slot.strftime("%H:%M")

# Track used cells to avoid overlaps
used_cells = defaultdict(set)  # {tech_name: set(row_nums)}

# Fill and merge cells per appointment
for col_idx, tech in enumerate(tech_names, start=2):
    for start, end, subject in schedule_map[tech]:
        start_str = start.strftime("%H:%M")
        end_str = end.strftime("%H:%M")

        start_row = time_row_map.get(start_str)
        end_row = time_row_map.get(end_str, len(time_slots) + 2)

        if start_row is None or end_row is None:
            continue

        # Only write if we haven't already used this block
        if any(r in used_cells[tech] for r in range(start_row, end_row)):
            continue

                # Write the subject first
        cell = ws_sched.cell(row=start_row, column=col_idx)
        cell.value = subject

        # Then merge the cells (start row to end row - 1)
        if end_row - start_row > 1:
            ws_sched.merge_cells(
                start_row=start_row, start_column=col_idx,
                end_row=end_row - 1, end_column=col_idx
            )

        for r in range(start_row, end_row):
            used_cells[tech].add(r)


# === Prepare data structure for visual layout ===
schedule_map = defaultdict(lambda: defaultdict(str))

# Fill the map with appointment slots
time_step = timedelta(minutes=30)  # adjust as needed
for i, appt in enumerate(appointments):
    tech = best[i]
    start = appt["start"]
    end = appt["end"]
    subject = appt["subject"]

    current_time = start
    while current_time < end:
        key = current_time.strftime("%H:%M")
        schedule_map[key][tech] = subject
        current_time += time_step

# Create new sheet
if "Schedule View" in wb.sheetnames:
    del wb["Schedule View"]
ws_sched = wb.create_sheet("Schedule View")

# Write headers
tech_names = [t["name"] for t in technicians]
ws_sched.append(["Time"] + tech_names)

# Sort time slots and fill rows
for time_slot in sorted(schedule_map.keys()):
    row = [time_slot]
    for tech in tech_names:
        row.append(schedule_map[time_slot].get(tech, ""))
    ws_sched.append(row)

wb.save("Outlook_Calendars.xlsx")
print(f"\nâœ… Optimized schedule written to 'Optimized Schedule' tab in Excel.")
