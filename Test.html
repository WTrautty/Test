#!/usr/bin/env python3
import os
import re
import pandas as pd
import argparse

def process_csv(file_path):
    """
    Processes a single CSV file.

    Opens the CSV in read-only mode using utf-8 (with a fallback to latin-1).
    Checks the "A5" cell (row 5, col 1 in Excel). If that cell has a value,
    the CSV is assumed to be vertical and is transposed.
    Then the function searches for cells that start with 'xyzzy' and end with 
    '23123' with a digit between (pattern: '^xyzzy\d23123$'). If the cell immediately 
    to the right is blank, it logs the result.
    
    Returns a list of result strings (one per finding).
    """
    results = []
    # Attempt to load the CSV with UTF-8 first, then fallback to Latin-1 if needed
    df = None
    for encoding in ['utf-8', 'latin-1']:
        try:
            df = pd.read_csv(file_path, header=None, dtype=str, encoding=encoding)
            break  # exit loop if read successfully
        except UnicodeDecodeError:
            continue
        except Exception as e:
            print(f"Error reading {file_path} with encoding {encoding}: {e}")
            return results
    if df is None:
        print(f"Failed to read {file_path} with both UTF-8 and Latin-1 encodings.")
        return results

    # Determine if CSV is stored vertically by checking the 5th row, first column (A5)
    if df.shape[0] >= 5:
        cell_value = df.iloc[4, 0]
        if pd.notna(cell_value) and str(cell_value).strip() != "":
            # If the cell is not empty, assume vertical orientation; transpose to horizontal
            df = df.transpose()

    # Compile the regex pattern:
    # This pattern matches strings that start with 'xyzzy', followed by exactly one digit, and end with '23123'.
    pattern = re.compile(r'^xyzzy\d23123$')
    
    # Loop through each cell in the DataFrame
    for i in range(df.shape[0]):
        for j in range(df.shape[1]):
            cell = df.iloc[i, j]
            cell_str = str(cell).strip()
            if pattern.match(cell_str):
                # Check the next cell to the right in the same row if it exists
                next_val = None
                if j + 1 < df.shape[1]:
                    next_val = df.iloc[i, j+1]
                # Determine if the next cell is blank (empty or NaN)
                if next_val is None or pd.isna(next_val) or str(next_val).strip() == "":
                    # Prepare a tab-delimited output line
                    line = f"{os.path.basename(file_path)}\t{file_path}\t{cell_str}\t{next_val}"
                    results.append(line)
    return results

def main():
    # Setup command-line argument parsing
    parser = argparse.ArgumentParser(
        description="Search CSV files for cells matching a regex pattern and check for blank next cells."
    )
    parser.add_argument(
        "--search-dir", type=str, required=True,
        help="Directory to search for CSV files (including subdirectories)."
    )
    parser.add_argument(
        "--output", type=str, required=True,
        help="File path for the output TXT file."
    )
    args = parser.parse_args()

    all_results = []

    # Walk through the directory and its subdirectories to find CSV files
    for root, _, files in os.walk(args.search_dir):
        for file in files:
            if file.lower().endswith(".csv"):
                file_path = os.path.join(root, file)
                results = process_csv(file_path)
                if results:
                    all_results.extend(results)

    # Write the findings to the designated output text file
    try:
        with open(args.output, "w") as out_file:
            for line in all_results:
                out_file.write(line + "\n")
        print(f"Results exported to: {args.output}")
    except Exception as e:
        print(f"Error writing output file: {e}")

if __name__ == "__main__":
    main()
