

import os
import glob
import pandas as pd

# Set the folder containing your CSV files.
folder_path = r'C:\Users\AD39644\OneDrive - Lumen\Documents - USDA Site and SDWAN Device Details\CSVs'

# List to hold details of CSV files that fail the condition.
failed_files = []

# Recursively get list of all CSV files.
csv_files = glob.glob(os.path.join(folder_path, '**', '*.csv'), recursive=True)
print(f"Found {len(csv_files)} CSV files.")

# Filter to only files with "xyzxyz" in the filename (case-insensitive).
target_csv_files = [f for f in csv_files if "xyzxyz" in os.path.basename(f).lower()]
print(f"Processing {len(target_csv_files)} CSV files with 'xyzxyz' in the name.")

for file_path in target_csv_files:
    try:
        # Try reading with UTF-8 encoding first; if that fails, try Latin-1.
        try:
            df = pd.read_csv(file_path, encoding='utf-8')
        except UnicodeDecodeError:
            df = pd.read_csv(file_path, encoding='latin1')
    except Exception as e:
        print(f"Error reading {file_path}: {e}")
        failed_files.append(f"Read Error: {os.path.basename(file_path)}\n{file_path}\n")
        continue

    # Check if the DataFrame has at least 2 columns.
    if df.shape[1] < 2:
        print(f"File {file_path} does not have at least 2 columns.")
        failed_files.append(f"Column Error: {os.path.basename(file_path)}\n{file_path}\n")
        continue

    # Assume the second column (index 1) holds the values.
    value_col = df.columns[1]
    file_failed = False
    details = ""

    # Iterate over rows to find a cell whose value ends with "sister".
    for i in range(len(df)):
        cell_value = str(df.iloc[i][value_col]).strip()
        if cell_value.lower().endswith("sister"):
            # Found a cell ending with "sister" â€“ now check the next row's value.
            candidate = ""
            next_idx = i + 1
            if next_idx < len(df):
                candidate = str(df.iloc[next_idx][value_col]).strip()
            # If the candidate is blank, check one row further.
            if candidate == "" and (next_idx + 1) < len(df):
                candidate = str(df.iloc[next_idx + 1][value_col]).strip()
                next_idx += 1  # Update the index used for candidate.
            # Now check if the candidate has at least 4 characters and the 4th character is "1".
            if len(candidate) < 4:
                details += (f"Row {i}: Found value ending with 'sister'. "
                            f"Candidate value '{candidate}' is too short to check 4th digit.\n")
                file_failed = True
            else:
                if candidate[3] != "1":
                    details += (f"Row {i}: Found value ending with 'sister'. "
                                f"Candidate value '{candidate}' (4th character is '{candidate[3]}', expected '1').\n")
                    file_failed = True
            # We check only the first occurrence in the file.
            break

    if file_failed:
        failed_files.append(f"{os.path.basename(file_path)}\n{file_path}\n{details}\n")

# Write the details of CSV files that failed the condition to an output text file.
output_file = r'C:\Users\AD39644\Desktop\output.txt'
with open(output_file, "w") as f:
    for entry in failed_files:
        f.write(entry + "\n")

print(f"Script completed. {len(failed_files)} file(s) did not meet the condition. See '{output_file}' for details.")

              
