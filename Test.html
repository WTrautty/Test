import re
import os

def mb_to_kbps(mb_str):
    return int(mb_str.lower().replace("mb", "")) * 1000

# === Set file paths ===
config_path = "/path/to/your/config.txt"
bandwidths_path = "/path/to/your/bandwidths.txt"

# === Validate paths ===
if not os.path.exists(config_path):
    raise FileNotFoundError(f"Config file not found at: {config_path}")
if not os.path.exists(bandwidths_path):
    raise FileNotFoundError(f"Bandwidths file not found at: {bandwidths_path}")

# === Load bandwidths ===
with open(bandwidths_path, "r") as bw_file:
    bandwidths = [mb_to_kbps(line.strip()) for line in bw_file if line.strip()]

# === Load config ===
with open(config_path, "r") as config_file:
    config_lines = config_file.readlines()

# === Split config into chunks ===
chunks = []
current_chunk = []
for line in config_lines:
    if "vprn" in line:
        if current_chunk:
            chunks.append(current_chunk)
            current_chunk = []
    current_chunk.append(line)
if current_chunk:
    chunks.append(current_chunk)

# === Compare expected bandwidth with rates in each chunk ===
for i, chunk in enumerate(chunks):
    if i >= len(bandwidths):
        print(f"⚠️ Not enough bandwidth entries for all chunks. Stopping at chunk {i}.")
        break

    expected_kbps = bandwidths[i]
    chunk_text = ''.join(chunk)
    rates = re.findall(r"\brate\s+(\d+)", chunk_text)
    cirs = re.findall(r"\bcir\s+(\d+)", chunk_text)

    all_rates = rates + cirs
    mismatches = [val for val in all_rates if int(val) != expected_kbps]

    if mismatches:
        print(f"\n❌ Mismatch in Chunk {i+1}:")
        print(f"  Expected: {expected_kbps} Kbps")
        print(f"  Found: {', '.join(all_rates)}")
