import re
import os

def mb_to_kbps(mb_str):
    return int(mb_str.lower().replace("mb", "")) * 1000

# === File Paths ===
config_path = "/path/to/your/config.txt"
bandwidths_path = "/path/to/your/bandwidths.txt"

# === Validate paths ===
if not os.path.exists(config_path):
    raise FileNotFoundError(f"Config file not found at: {config_path}")
if not os.path.exists(bandwidths_path):
    raise FileNotFoundError(f"Bandwidths file not found at: {bandwidths_path}")

# === Load bandwidths ===
with open(bandwidths_path, "r") as bw_file:
    raw_bandwidths = [line.strip() for line in bw_file if line.strip()]
    bandwidths = [mb_to_kbps(bw) for bw in raw_bandwidths]

# === Load config ===
with open(config_path, "r") as config_file:
    config_lines = config_file.readlines()

# === Split config into chunks based on 'vprn' ===
chunks = []
current_chunk = []
for line in config_lines:
    if "vprn" in line:
        if current_chunk:
            chunks.append(current_chunk)
            current_chunk = []
    current_chunk.append(line)
if current_chunk:
    chunks.append(current_chunk)

# === Compare each chunk's rates/cirs to expected bandwidth ===
for i, chunk in enumerate(chunks):
    if i >= len(bandwidths):
        print(f"\n⚠️ Not enough bandwidths provided. Chunk {i+1} has no corresponding value.")
        continue

    expected = bandwidths[i]
    bw_line_number = i + 1
    chunk_has_mismatch = False

    for line_number, line in enumerate(chunk):
        # Match rate or cir
        rate_match = re.search(r"\brate\s+(\d+)", line)
        cir_match = re.search(r"\bcir\s+(\d+)", line)

        for label, match in [("rate", rate_match), ("cir", cir_match)]:
            if match:
                actual = int(match.group(1))
                if actual != expected:
                    if not chunk_has_mismatch:
                        print(f"\n❌ Mismatch in Chunk {i+1} (Bandwidth line {bw_line_number}): Expected {expected} Kbps")
                        chunk_has_mismatch = True
                    print(f"  → Line {line_number+1} in chunk: Found {label} {actual}")

    if not chunk_has_mismatch:
        print(f"[✅] Chunk {i+1} matched expected {expected} Kbps (from bandwidth line {bw_line_number})")
