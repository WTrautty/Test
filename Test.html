import os
import glob
import re
import pandas as pd

# Set the folder containing your CSV files.
folder_path = r'c:\CSVs\2025\02-February'

# List to hold details of CSV files that fail the condition.
failed_files = []

# Recursively get a list of all CSV files.
csv_files = glob.glob(os.path.join(folder_path, '**', '*.csv'), recursive=True)
print(f"Found {len(csv_files)} CSV files. Beginning checks...")

# Filter to only files with "csv" in the filename (case-insensitive).
target_csv_files = [f for f in csv_files if "csv" in os.path.basename(f).lower()]

# Regex pattern to match exactly 9 digits.
id_pattern = re.compile(r'^\d{9}$')

# Regex to check for specific value start and end pattern.
custom_pattern = re.compile(r'^.*vpn_lan_subif.*name/interface/shutdown$')

# Mapping for /64 region extraction.
ip_region_map = {
    '8': 'East',
    '9': 'Central',
    'A': 'Mountain', 'a': 'Mountain',
    'B': 'West', 'b': 'West'
}
id_region_map = {
    '1': 'East',
    '2': 'Central',
    '3': 'Mountain',
    '4': 'West'
}

for file_path in target_csv_files:
    try:
        try:
            df = pd.read_csv(file_path, encoding='utf-8', header=None)
        except UnicodeDecodeError:
            df = pd.read_csv(file_path, encoding='latin1', header=None)
    except Exception as e:
        failed_files.append(f"Read Error: {os.path.basename(file_path)}\n{file_path}\nError: {e}\n")
        continue

    print(f"\nChecking file: {file_path}")
    has_RoIP = df.astype(str).apply(lambda col: col.str.contains("RoIP", case=False, na=False)).any().any()
    print(f"Contains 'RoIP': {has_RoIP}")
    file_flagged = False
    candidate_details = []

    found_ids = []
    id_region_set = set()
    ip_regions = []

    for row_idx, row in df.iterrows():
        for col_idx, cell in enumerate(row):
            cell_value = str(cell).strip()

            # 9-digit ID check.
            if id_pattern.fullmatch(cell_value):
                print(f"Found ID: {cell_value}")
                found_ids.append(cell_value)
                id_region = id_region_map.get(cell_value[0])
                print(f"  ID region: {id_region}")
                if id_region:
                    id_region_set.add(id_region)
                if has_RoIP and len(cell_value) >= 4:
                    if cell_value[3] != "1":
                        candidate_details.append(
                            f"Candidate value '{cell_value}' fails: 4th digit is '{cell_value[3]}' (expected '1')."
                        )
                        file_flagged = True
                elif has_RoIP and len(cell_value) < 4:
                    candidate_details.append(f"Candidate value '{cell_value}' is too short.")
                    file_flagged = True

            # vpn_lan_subif check (independent)
            if custom_pattern.match(cell_value) and not cell_value.startswith('/200/'):
                next_val_right = str(row[col_idx + 1]).strip().upper() if col_idx + 1 < len(row) else ""
                next_val_below = str(df.iloc[row_idx + 1, col_idx]).strip().upper() if row_idx + 1 < len(df) else ""

                if next_val_right != "TRUE" and next_val_below != "TRUE":
                    candidate_details.append(
                        f"'{cell_value}' followed by '{next_val_right}' (right) and '{next_val_below}' (below), both not 'TRUE'."
                    )
                    file_flagged = True

            # /64 IP region match check (independent)
            if cell_value.endswith("/64"):
                ip_parts = cell_value.split(":")
                if len(ip_parts) > 1 and len(ip_parts[1]) >= 3:
                    region_char = ip_parts[1][2]
                    ip_region = ip_region_map.get(region_char)
                    print(f"Found /64: {cell_value}, extracted char: {region_char}, mapped region: {ip_region}")
                    if ip_region:
                        ip_regions.append((cell_value, ip_region))

    print(f"All ID regions found: {id_region_set}")
    print(f"All /64 IP regions found: {ip_regions}")

    # Region mismatch check
    for ip_val, ip_region in ip_regions:
        for id_region in id_region_set:
            if ip_region != id_region:
                print(f"Mismatch found -> ID Region: {id_region}, IP: {ip_val}, IP Region: {ip_region}")
                candidate_details.append(
                    f"Mismatch: IP '{ip_val}' maps to region '{ip_region}' but does not match ID region '{id_region}'."
                )
                file_flagged = True

    if file_flagged:
        details = "\n".join(candidate_details)
        failed_files.append(f"{os.path.basename(file_path)}\n{file_path}\n{details}\n")

# Write the details of CSV files that failed the condition to an output text file.
output_file = r'C:\Desktop\output.txt'
with open(output_file, "w") as f:
    for entry in failed_files:
        f.write(entry + "\n")

print(f"Script completed. {len(failed_files)} file(s) did not meet the conditions. See '{output_file}' for details.")
