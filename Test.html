#!/usr/bin/env python3
import os
import re
import pandas as pd
import argparse

def process_csv(file_path):
    """
    Processes a single CSV file.
    
    Opens the CSV in read-only mode (tries UTF-8 first, then Latin-1 if needed),
    checks the "A5" cell (row 5, col 1 in Excel) to determine orientation, transposes
    if necessary, and searches for cells matching the regex pattern.
    
    The regex looks for values that start with 'xyzzy', followed by exactly one digit, 
    and end with '23123' (e.g., "xyzzy423123"). If the cell immediately to the right is blank,
    a result is recorded.
    
    Returns a list of result strings (one per finding).
    """
    results = []
    # Try to load the CSV with UTF-8 first, then fallback to Latin-1 if needed
    df = None
    for encoding in ['utf-8', 'latin-1']:
        try:
            df = pd.read_csv(file_path, header=None, dtype=str, encoding=encoding)
            break
        except UnicodeDecodeError:
            continue
        except Exception as e:
            print(f"Error reading {file_path} with encoding {encoding}: {e}")
            return results
    if df is None:
        print(f"Failed to read {file_path} with both UTF-8 and Latin-1 encodings.")
        return results

    # Determine if CSV is stored vertically by checking the 5th row, first column (A5)
    if df.shape[0] >= 5:
        cell_value = df.iloc[4, 0]
        if pd.notna(cell_value) and str(cell_value).strip() != "":
            # If the cell is not empty, assume vertical orientation; transpose to horizontal
            df = df.transpose()

    # Compile the regex pattern:
    # Pattern: starts with 'xyzzy', followed by exactly one digit, and ends with '23123'
    pattern = re.compile(r'^xyzzy\d23123$')

    # Loop through each cell in the DataFrame
    for i in range(df.shape[0]):
        for j in range(df.shape[1]):
            cell = df.iloc[i, j]
            cell_str = str(cell).strip()
            if pattern.match(cell_str):
                # Check the next cell to the right in the same row if it exists
                next_val = None
                if j + 1 < df.shape[1]:
                    next_val = df.iloc[i, j+1]
                # Determine if the next cell is blank (empty or NaN)
                if next_val is None or pd.isna(next_val) or str(next_val).strip() == "":
                    # Prepare a tab-delimited output line
                    line = f"{os.path.basename(file_path)}\t{file_path}\t{cell_str}\t{next_val}"
                    results.append(line)
    return results

def main():
    # Setup command-line argument parsing for two positional arguments
    parser = argparse.ArgumentParser(
        description="Search CSV files for cells matching a regex pattern and check if the next cell is blank."
    )
    parser.add_argument(
        "search_path", type=str,
        help="Path to a CSV file or directory to search for CSV files."
    )
    parser.add_argument(
        "export_path", type=str,
        help="File path for the output TXT file."
    )
    args = parser.parse_args()

    all_results = []

    # If search_path is a directory, search recursively for CSV files
    if os.path.isdir(args.search_path):
        for root, _, files in os.walk(args.search_path):
            for file in files:
                if file.lower().endswith(".csv"):
                    file_path = os.path.join(root, file)
                    results = process_csv(file_path)
                    if results:
                        all_results.extend(results)
    # If search_path is a file, process it directly if it's a CSV file
    elif os.path.isfile(args.search_path) and args.search_path.lower().endswith(".csv"):
        results = process_csv(args.search_path)
        if results:
            all_results.extend(results)
    else:
        print(f"Provided search path {args.search_path} is neither a CSV file nor a directory.")
        return

    # Write the results to the designated output text file
    try:
        with open(args.export_path, "w") as out_file:
            for line in all_results:
                out_file.write(line + "\n")
        print(f"Results exported to: {args.export_path}")
    except Exception as e:
        print(f"Error writing output file: {e}")

if __name__ == "__main__":
    main()
