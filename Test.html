#!/usr/bin/env python3
import os
import sys
import paramiko
import getpass
from typing import List, Dict

def load_commands_from_file(file_path: str, delimiter: str = "&!") -> List[str]:
    """
    Reads a file and splits its content into commands based on the given delimiter.
    
    Args:
        file_path: The path to the file containing commands.
        delimiter: The delimiter used to separate commands.
        
    Returns:
        A list of command strings.
    """
    try:
        with open(file_path, 'r') as file:
            content = file.read().strip()
            # Split based on the delimiter and remove any empty strings
            commands = [cmd.strip() for cmd in content.split(delimiter) if cmd.strip()]
        return commands
    except IOError as e:
        print(f"Error reading {file_path}: {e}")
        return []

def load_commands_from_folder(folder_path: str, delimiter: str = "&!") -> List[str]:
    """
    Reads all .txt files in the given folder, splits their content into individual commands
    using the specified delimiter, and returns a list of commands.
    
    Args:
        folder_path: The path to the folder containing .txt files.
        delimiter: The delimiter used to separate commands within each file.
    
    Returns:
        A list of command strings from all files.
    """
    commands = []
    for filename in os.listdir(folder_path):
        if filename.lower().endswith('.txt'):
            file_path = os.path.join(folder_path, filename)
            file_commands = load_commands_from_file(file_path, delimiter)
            commands.extend(file_commands)
    return commands

def run_commands_on_bastion(hostname: str, username: str, commands: List[str]) -> List[Dict[str, str]]:
    """
    Connects to the bastion host using an MFA code as the password and executes commands sequentially.
    It waits for each command to complete before sending the next command.
    
    Args:
        hostname: The bastion host's address.
        username: The username to log in as.
        commands: A list of commands to execute.
    
    Returns:
        A list of dictionaries containing each command's output, exit status, and error output.
    """
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        # Prompt for MFA code securely
        mfa_code = getpass.getpass(prompt="Enter MFA code: ").strip()
        print("Attempting to connect to bastion...")
        ssh.connect(hostname, username=username, password=mfa_code)
        print("Successfully connected to bastion.")
        
        results = []
        for cmd in commands:
            print(f"\nExecuting command: {cmd}")
            stdin, stdout, stderr = ssh.exec_command(cmd)
            # Wait for the command to complete by retrieving its exit status
            exit_status = stdout.channel.recv_exit_status()
            output = stdout.read().decode().strip()
            error = stderr.read().decode().strip()
            if output:
                print(f"Output: {output}")
            if error:
                print(f"Error: {error}")
            results.append({
                "command": cmd,
                "exit_status": exit_status,
                "output": output,
                "error": error,
            })
        return results
    except paramiko.AuthenticationException:
        print("Authentication failed. Please check your MFA code.")
        sys.exit(1)
    except paramiko.SSHException as e:
        print(f"SSH error occurred: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Connection failed: {e}")
        sys.exit(1)
    finally:
        ssh.close()

def main() -> None:
    """
    Main function to prompt the user for connection details, load commands from text files,
    and execute those commands on the bastion host.
    """
    hostname = input("Enter bastion hostname: ").strip()
    username = input("Enter username: ").strip()
    folder = input("Enter folder path containing command .txt files: ").strip()
    
    if not os.path.isdir(folder):
        print("Provided folder path does not exist or is not a directory.")
        sys.exit(1)
    
    commands = load_commands_from_folder(folder)
    if not commands:
        print("No commands found in the specified folder.")
        sys.exit(1)
    
    run_commands_on_bastion(hostname, username, commands)

if __name__ == "__main__":
    main()
