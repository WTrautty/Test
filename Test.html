import openpyxl
import random
import math
from datetime import datetime, timedelta
from collections import defaultdict
from openpyxl.styles import Alignment
from openpyxl.utils import get_column_letter

# === Load Excel Workbook ===
wb = openpyxl.load_workbook("Outlook_Calendars.xlsx")
appointments = []
technicians = []

# === Add or Reset Technicians Sheet ===
if "Technicians" in wb.sheetnames:
    wb.remove(wb["Technicians"])
ws_tech = wb.create_sheet("Technicians")
ws_tech.append(["Technician", "Available Start", "Available End", "Max Appointments"])

# Sample technician data
sample_techs = [
    ("Alice", "08:00", "16:00", 5),
    ("Bob", "09:00", "17:00", 4),
    ("Charlie", "07:30", "15:30", 6),
    ("Dana", "10:00", "18:00", 3),
    ("Jim", "08:00", "16:00", 5),
    ("Berry", "09:00", "17:00", 4),
    ("Chie", "07:30", "15:30", 6),
    ("Dads", "10:00", "18:00", 3),
]

for tech in sample_techs:
    ws_tech.append(tech)

# === Load Technicians into List ===
for row in ws_tech.iter_rows(min_row=2, values_only=True):
    technicians.append({
        "name": row[0],
        "start": datetime.strptime(row[1], "%H:%M").time(),
        "end": datetime.strptime(row[2], "%H:%M").time(),
        "max": row[3],
    })

# === Load Appointments from First Mailbox Sheet ===
mailbox_sheet = [ws for ws in wb.sheetnames if ws not in ["Technicians", "Optimized Schedule", "Schedule View"]][0]
ws_appt = wb[mailbox_sheet]
for row in ws_appt.iter_rows(min_row=2, values_only=True):
    try:
        start_time = row[1]
        end_time = row[2]
        appointments.append({
            "subject": row[0],
            "start": start_time,
            "end": end_time,
            "duration": (end_time - start_time).total_seconds() / 60,
            "location": row[3],
        })
    except Exception:
        continue

# === Simulated Annealing ===
def cost(schedule):
    penalty = 0
    tech_counts = {t["name"]: 0 for t in technicians}

    for i, appt in enumerate(appointments):
        tech = schedule[i]
        tech_info = next(t for t in technicians if t["name"] == tech)
        tech_counts[tech] += 1

        if tech_counts[tech] > tech_info["max"]:
            penalty += 100  # Overbooked

        if not (tech_info["start"] <= appt["start"].time() <= tech_info["end"]):
            penalty += 50  # Outside working hours

    return penalty

# === Initialize Random Assignment ===
current = [random.choice(technicians)["name"] for _ in appointments]
best = list(current)
best_cost = cost(best)

T = 1000.0
T_min = 1.0
alpha = 0.95

while T > T_min:
    i = random.randint(0, len(appointments)-1)
    new = list(current)
    new[i] = random.choice(technicians)["name"]

    curr_cost = cost(current)
    new_cost = cost(new)

    if new_cost < curr_cost or math.exp((curr_cost - new_cost) / T) > random.random():
        current = new
        if new_cost < best_cost:
            best = new
            best_cost = new_cost

    T *= alpha

# === Write Optimized Schedule ===
if "Optimized Schedule" in wb.sheetnames:
    del wb["Optimized Schedule"]
ws_out = wb.create_sheet("Optimized Schedule")
ws_out.append(["Subject", "Start", "End", "Location", "Assigned Technician"])

for i, appt in enumerate(appointments):
    ws_out.append([
        appt["subject"],
        appt["start"],
        appt["end"],
        appt["location"],
        best[i],
    ])

# === Create Schedule View Sheet with Merged Blocks ===
if "Schedule View" in wb.sheetnames:
    del wb["Schedule View"]
ws_sched = wb.create_sheet("Schedule View")

# Build schedule map by technician
schedule_map = defaultdict(list)  # {tech_name: [(start_time, end_time, subject)]}
for i, appt in enumerate(appointments):
    schedule_map[best[i]].append((appt["start"], appt["end"], appt["subject"]))

# Define time range (30 min slots)
all_times = [appt["start"] for appt in appointments] + [appt["end"] for appt in appointments]
min_time = min(all_times).replace(minute=0)
max_time = max(all_times)
time_slots = []
cur = min_time
while cur <= max_time:
    time_slots.append(cur)
    cur += timedelta(minutes=30)

# Write header row
tech_names = [t["name"] for t in technicians]
ws_sched.append(["Time"] + tech_names)

# Row map to use for merging
time_row_map = {slot.strftime("%H:%M"): idx + 2 for idx, slot in enumerate(time_slots)}

# Fill time labels in first column
for idx, slot in enumerate(time_slots):
    ws_sched.cell(row=idx + 2, column=1).value = slot.strftime("%H:%M")

# Track used cells to avoid double-writing
used_cells = defaultdict(set)  # {tech_name: set(row_nums)}

# Write each tech's appointments and merge cells
for col_idx, tech in enumerate(tech_names, start=2):
    for start, end, subject in schedule_map[tech]:
        start_str = start.strftime("%H:%M")
        end_str = end.strftime("%H:%M")

        start_row = time_row_map.get(start_str)
        end_row = time_row_map.get(end_str, len(time_slots) + 2)

        if start_row is None or end_row is None:
            continue

        if any(r in used_cells[tech] for r in range(start_row, end_row)):
            continue

        cell = ws_sched.cell(row=start_row, column=col_idx)
        cell.value = subject
        cell.alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)

        if end_row - start_row > 1:
            ws_sched.merge_cells(
                start_row=start_row, start_column=col_idx,
                end_row=end_row - 1, end_column=col_idx
            )

        for r in range(start_row, end_row):
            used_cells[tech].add(r)

# === Save the Workbook ===
wb.save("Outlook_Calendars.xlsx")
print("\nâœ… Optimized schedule and visual calendar saved to 'Outlook_Calendars.xlsx'")
