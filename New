import csv
import re
from datetime import datetime

import win32com.client


# =========================
# CONFIG (edit these)
# =========================

SEARCH_WORD = "Success"  # subject contains this (case-insensitive)

# Where to read mail from:
# - Most people want "Sent Items"
# - If you truly meant Outbox, change FOLDER_NAME to "Outbox" (but that usually contains unsent mail)
MAILBOX_NAME = None      # None = default mailbox; or set like "Your Name" / "you@company.com"
FOLDER_NAME = "Sent Items"

# Only process most recent N messages (helps performance). Set to None to process all.
MAX_ITEMS = 5000

OUTPUT_CSV_PATH = r"C:\Temp\success_emails_parsed.csv"

# Everything before this marker is ignored in the body.
# Set to None if you do NOT want a start marker.
START_MARKER = "----- RECOVERY CODE -----"

# Delimiters to extract (these become column headers without the trailing ":")
# Example: body contains "Auditor: Wyatt", "IC Error: N", etc.
DELIMITERS = [
    "Auditor:",
    "IC Error:",
    "Failure Groups:",
    "Failure Notes:",
]


# =========================
# Parsing helpers
# =========================

def header_from_delim(delim: str) -> str:
    # Turn "Auditor:" into "Auditor"
    return delim.rstrip(":").strip()

def normalize_text(s: str) -> str:
    if s is None:
        return ""
    # Keep content but make it CSV-friendly
    return s.replace("\r\n", "\n").replace("\r", "\n").strip()

def slice_from_start_marker(body: str, start_marker: str | None) -> str:
    body = body or ""
    if not start_marker:
        return body
    idx = body.lower().find(start_marker.lower())
    if idx == -1:
        return body  # marker not found -> keep whole body (or change to "" if you prefer)
    return body[idx:]  # include marker and everything after

def extract_sections(body: str, delimiters: list[str]) -> dict:
    """
    Extract text for each delimiter from body.
    Strategy:
      - Find each delimiter position (case-insensitive)
      - Section value is text from end of this delimiter to start of next delimiter (or end of body)
    """
    text = body or ""
    lower = text.lower()

    # Find all delimiter occurrences
    hits = []
    for d in delimiters:
        pos = lower.find(d.lower())
        if pos != -1:
            hits.append((pos, d))

    # Sort by where they appear in the body
    hits.sort(key=lambda x: x[0])

    # If a delimiter is missing, we still output blank for that column
    results = {header_from_delim(d): "" for d in delimiters}

    for i, (start_pos, delim) in enumerate(hits):
        start_val = start_pos + len(delim)
        end_val = hits[i + 1][0] if i + 1 < len(hits) else len(text)
        value = text[start_val:end_val].strip()

        # Optional cleanup: remove leading ":" or whitespace if someone wrote "Auditor::"
        value = re.sub(r"^\s*:\s*", "", value).strip()

        results[header_from_delim(delim)] = normalize_text(value)

    return results


# =========================
# Outlook read + CSV export
# =========================

def get_outlook_folder(namespace, mailbox_name: str | None, folder_name: str):
    """
    Returns the Outlook MAPIFolder for the mailbox/folder requested.
    """
    if mailbox_name:
        root = namespace.Folders.Item(mailbox_name)
    else:
        # Default mailbox root
        root = namespace.Folders.Item(1)

    return root.Folders.Item(folder_name)

def main():
    outlook = win32com.client.Dispatch("Outlook.Application")
    namespace = outlook.GetNamespace("MAPI")

    folder = get_outlook_folder(namespace, MAILBOX_NAME, FOLDER_NAME)

    items = folder.Items
    # Sort newest first (SentOn exists for sent mail)
    try:
        items.Sort("[SentOn]", True)
    except Exception:
        # Some folders may not support SentOn sorting; ignore if so
        pass

    # Build CSV headers
    parsed_headers = [header_from_delim(d) for d in DELIMITERS]
    fieldnames = ["Subject", "DateSent"] + parsed_headers

    count_written = 0
    count_scanned = 0

    with open(OUTPUT_CSV_PATH, "w", newline="", encoding="utf-8-sig") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames, quoting=csv.QUOTE_ALL)
        writer.writeheader()

        for item in items:
            # Stop if we hit MAX_ITEMS
            if MAX_ITEMS is not None and count_scanned >= MAX_ITEMS:
                break

            count_scanned += 1

            # Only MailItem (Class 43)
            try:
                if item.Class != 43:
                    continue
            except Exception:
                continue

            subject = getattr(item, "Subject", "") or ""
            if SEARCH_WORD.lower() not in subject.lower():
                continue

            sent_on = getattr(item, "SentOn", None)
            if sent_on:
                # Outlook COM datetime -> python datetime
                date_str = datetime.fromtimestamp(int(sent_on.timestamp())).strftime("%m/%d/%Y") \
                    if hasattr(sent_on, "timestamp") else sent_on.strftime("%m/%d/%Y")
            else:
                date_str = ""

            body = getattr(item, "Body", "") or ""
            body = slice_from_start_marker(body, START_MARKER)

            sections = extract_sections(body, DELIMITERS)

            row = {
                "Subject": normalize_text(subject),
                "DateSent": date_str,
                **sections,
            }
            writer.writerow(row)
            count_written += 1

    print(f"Done. Scanned: {count_scanned}, Exported: {count_written}")
    print(f"CSV saved to: {OUTPUT_CSV_PATH}")


if __name__ == "__main__":
    main()
