import os
import time
import sqlite3
from pathlib import Path

import pandas as pd

# Requires: pywin32  (pip install pywin32)
import win32com.client


# -----------------------------
# CONFIG
# -----------------------------
EXCEL_PATH = r"C:\Users\YourUser\OneDrive - YourOrg\YourLibrary\source_workbook.xlsx"

# OneDrive-synced folder that maps to the SharePoint document library
# Example: C:\Users\You\OneDrive - OrgName\Shared Documents\SomeFolder
SHAREPOINT_SYNC_FOLDER = r"C:\Users\YourUser\OneDrive - YourOrg\Shared Documents\PowerBI_Staging"

DB_NAME = "staging.db"
DB_PATH = str(Path(SHAREPOINT_SYNC_FOLDER) / DB_NAME)

# You can load either:
#   A) three worksheets by name:
SHEETS_TO_EXPORT = [
    ("Sheet1", "table_sheet1"),
    ("Sheet2", "table_sheet2"),
    ("Sheet3", "table_sheet3"),
]

# OR
#   B) three Excel "Tables" (ListObjects) by name instead of sheets
#      If you prefer that, set USE_EXCEL_TABLES=True and list table names here.
USE_EXCEL_TABLES = False
EXCEL_TABLES_TO_EXPORT = [
    ("Table1", "table1"),
    ("Table2", "table2"),
    ("Table3", "table3"),
]

# Refresh settings
REFRESH_TIMEOUT_SECONDS = 30 * 60  # 30 minutes
POLL_SECONDS = 2


# -----------------------------
# EXCEL REFRESH
# -----------------------------
def refresh_excel_workbook(excel_path: str) -> None:
    """
    Opens workbook in Excel, triggers RefreshAll, waits until all async queries finish, then saves & closes.
    Works best for Power Query / external connections.
    """
    excel = win32com.client.DispatchEx("Excel.Application")
    excel.Visible = False
    excel.DisplayAlerts = False
    excel.AskToUpdateLinks = False

    wb = None
    try:
        wb = excel.Workbooks.Open(excel_path, UpdateLinks=0, ReadOnly=False)

        # Trigger refresh (Power Query, connections, pivots, etc.)
        wb.RefreshAll()

        # Wait for completion
        start = time.time()
        while True:
            # For Power Query / background refresh:
            try:
                # This blocks until async queries finish
                excel.CalculateUntilAsyncQueriesDone()
            except Exception:
                # Not always available / may fail depending on Excel version.
                pass

            # Check if any connections are still refreshing
            refreshing = False
            try:
                for conn in wb.Connections:
                    try:
                        if conn.OLEDBConnection.Refreshing:
                            refreshing = True
                            break
                    except Exception:
                        # Some connection types don't support OLEDBConnection
                        pass
            except Exception:
                pass

            if not refreshing:
                break

            if (time.time() - start) > REFRESH_TIMEOUT_SECONDS:
                raise TimeoutError(f"Excel refresh exceeded {REFRESH_TIMEOUT_SECONDS} seconds.")

            time.sleep(POLL_SECONDS)

        # Save results
        wb.Save()

    finally:
        if wb is not None:
            try:
                wb.Close(SaveChanges=True)
            except Exception:
                pass
        try:
            excel.Quit()
        except Exception:
            pass


# -----------------------------
# EXPORT TO SQLITE
# -----------------------------
def dataframe_to_sqlite(df: pd.DataFrame, conn: sqlite3.Connection, table_name: str) -> None:
    """
    Writes df to SQLite, replacing the table each run.
    """
    # Normalize column names a bit (optional but helpful)
    df.columns = [str(c).strip().replace("\n", " ").replace("\r", " ") for c in df.columns]

    # Write
    df.to_sql(table_name, conn, if_exists="replace", index=False)


def export_excel_to_sqlite(excel_path: str, db_path: str) -> None:
    """
    Reads Excel (already refreshed), exports specified sheets or tables to SQLite.
    """
    Path(db_path).parent.mkdir(parents=True, exist_ok=True)

    # Connect SQLite
    with sqlite3.connect(db_path) as conn:
        # Improve write reliability and speed
        conn.execute("PRAGMA journal_mode=WAL;")
        conn.execute("PRAGMA synchronous=NORMAL;")

        if USE_EXCEL_TABLES:
            # Read Excel Tables via pandas:
            # pandas doesn't directly read ListObjects by name without helper logic.
            # The most reliable approach (no COM) is: put each table on its own sheet
            # OR use COM to extract table ranges. We'll do COM extraction if enabled.
            excel = win32com.client.DispatchEx("Excel.Application")
            excel.Visible = False
            excel.DisplayAlerts = False
            wb = None
            try:
                wb = excel.Workbooks.Open(excel_path, UpdateLinks=0, ReadOnly=True)

                for excel_table_name, sqlite_table_name in EXCEL_TABLES_TO_EXPORT:
                    df = extract_excel_table_as_dataframe(wb, excel_table_name)
                    dataframe_to_sqlite(df, conn, sqlite_table_name)

            finally:
                if wb is not None:
                    try:
                        wb.Close(SaveChanges=False)
                    except Exception:
                        pass
                try:
                    excel.Quit()
                except Exception:
                    pass

        else:
            # Read worksheets by name (simple & reliable)
            for sheet_name, sqlite_table_name in SHEETS_TO_EXPORT:
                df = pd.read_excel(excel_path, sheet_name=sheet_name, engine="openpyxl")
                dataframe_to_sqlite(df, conn, sqlite_table_name)


def extract_excel_table_as_dataframe(wb, table_name: str) -> pd.DataFrame:
    """
    Extract a ListObject (Excel Table) by name from any sheet using COM, return as DataFrame.
    """
    for ws in wb.Worksheets:
        try:
            for lo in ws.ListObjects:
                if str(lo.Name).strip().lower() == table_name.strip().lower():
                    # Get range values (includes headers)
                    values = lo.Range.Value
                    headers = list(values[0])
                    rows = list(values[1:])
                    return pd.DataFrame(rows, columns=headers)
        except Exception:
            continue

    raise ValueError(f"Excel table '{table_name}' not found in workbook.")


# -----------------------------
# MAIN
# -----------------------------
def main():
    if not os.path.exists(EXCEL_PATH):
        raise FileNotFoundError(f"Excel file not found: {EXCEL_PATH}")

    if not os.path.isdir(SHAREPOINT_SYNC_FOLDER):
        raise FileNotFoundError(
            f"OneDrive/SharePoint sync folder not found: {SHAREPOINT_SYNC_FOLDER}\n"
            f"Make sure the SharePoint library is synced locally via OneDrive."
        )

    print("1) Refreshing Excel workbook...")
    refresh_excel_workbook(EXCEL_PATH)
    print("   Refresh complete.")

    print("2) Exporting refreshed Excel data to SQLite DB...")
    export_excel_to_sqlite(EXCEL_PATH, DB_PATH)
    print(f"   DB written to: {DB_PATH}")

    print("Done. OneDrive will sync the .db to SharePoint automatically.")


if __name__ == "__main__":
    main()
